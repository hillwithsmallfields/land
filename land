#!/usr/bin/python3

# Program to configure and install one of my usual environments on a
# freshly-installed Raspian (or other system).
#
# Run like this, on the target host:
#
# curl https://raw.githubusercontent.com/hillwithsmallfields/land/trunk/land | sudo python3

import argparse
import getpass
import glob
import json
import logging
import os
import pwd
import re
import requests
import shutil
import socket
import sys
import time
import uuid

#################
# File handling #
#################

dirmask = 0o755

MODEL_FILENAME = "/proc/device-tree/model"

def file_has_line_starting(filename, incipit):
    """Return whether a file contains a line starting with a given marker."""
    with open(filename, 'r') as stream:
        return any((line.startswith(incipit) for line in stream))

def append_to_file_if_missing(filename, incipit, addendum):
    """If a file doesn't contain a line with a given marker,
    add a specified string at the end."""
    if not file_has_line_starting(filename, incipit):
        with open(filename, 'a') as contents:
            contents.write(addendum)

def prepend_to_lines_starting(filename, incipit, addendum):
    """To any lines in a file starting with a given marker,
    ensure that they start with a given string.
    Meant for commenting out lines of config files."""
    with open(filename, 'r') as stream:
        lines = [line for line in stream]
    with open(filename, 'w') as stream:
        for line in lines:
            if line.startswith(incipit):
                line = addendum + line
            stream.write(line)

def append_to_lines_starting(filename, incipit, addendum):
    """To any lines in a file starting with a given marker,
    ensure that they end in a given string."""
    with open(filename, 'r') as stream:
        lines = [line for line in stream]
    with open(filename, 'w') as stream:
        for line in lines:
            if line.startswith(incipit) and not line.endswith(addendum):
                line = line[:-1] + addendum + line[-1]
            stream.write(line)

def replace_string_in_file(filename, oldstring, newstring):
    """Replace all occurrences of a string in a file."""
    with open(filename, 'r') as stream:
        lines = [line for line in stream]
    with open(filename, 'w') as stream:
        for line in lines:
            stream.write(line.replace(oldstring, newstring))

def git_site_author_and_repo(repo):
    """Get the user and author parts of a repo URL."""
    matched = re.match("https://([^/]+)/", repo)
    if matched:
        parts = repo.split("/")
        return matched.group(1), "/".join(parts[3:-1]), os.path.splitext(parts[-1])[0]
    matched = re.match("git@([^/]+):", repo)
    if matched:
        parts = repo.split(':')[1].split('/')
        return matched.group(1), parts[0], os.path.splitext(parts[1])[0]
    return "anon"

def model():
    # https://gist.github.com/jperkin/c37a574379ef71e339361954be96be12
    # yields these (after the transformations we do):
    #
    # 2-Model-B
    # 3-Model-B
    # 3-Model-B Plus
    # 4-Model-B
    # Compute-Module
    # Compute-Module-3
    # Compute-Module-3-Plus
    # Model-B
    # Model-B Plus
    # Zero-W
    #
    if os.path.isfile(MODEL_FILENAME):
        with open(MODEL_FILENAME) as model_stream:
            found = re.search("Raspberry Pi (.+)( Rev.+ )?", model_stream.read())
            return found.group(1).replace(' ', '-') if found else "unknown"
    else:
        return "not-a-pi"

def file_contents(filename):
    """Return the contents of a file."""
    if os.path.exists(filename):
        with open(filename) as filestream:
            return filestream.read()
    return None

##########################
# Configuration handling #
##########################

def merge(old, new):
    """Merge two configurations."""
    for k, v in new.items():
        if k in old:
            if isinstance(old[k], list):
                if isinstance(v, list):
                    old[k] += [nv for nv in v if nv not in old[k]]
                else:
                    old[k].append(v)
            elif isinstance(old[k], dict):
                if isinstance(v, dict):
                    merge(old[k], v)
                else:
                    logging.warn("cannot merge non-dict %s into dict", v)
            else:
                old[k] = v
        else:
            old[k] = v
    return old

def activate(subconf_name, conf, active, classes):
    """If a given name occurs in a configuration dictionary,
    bring its contents into the active configuration."""
    if subconf_name in conf:
        merge(active, conf[subconf_name])
    get_includes(active, classes)

def get_includes(conf, classes):
    """Process any includes and superclasses at the top level of a configuration."""
    if 'includes' in conf:
        includes = conf['includes']
        del conf['includes']
        for inc in includes:
            get_configuration(inc, conf)
    if 'superclasses' in conf:
        superclasses = conf['superclasses']
        del conf['superclasses']
        for sup in superclasses:
            activate(sup, classes, conf, classes)

def get_configuration(confname, classes, existing=None):
    """Fetch a configuration from file or the web."""
    if existing is None:
        existing = {}
    if confname.split(':', 1)[0] in ('https', 'http'):
        conf = requests.get(confname).json()
    else:
        with open(confname) as confstream:
            conf = json.load(confstream)
    merge(existing, conf)
    get_includes(existing, classes)
    return existing

#######################
# Host and user setup #
#######################

def set_hostname(newname):
    """Set this machine's hostname."""
    oldname = socket.gethostname()
    if newname != oldname:
        with open("/etc/hostname", 'w') as namestream:
            namestream.write(newname + '\n')
        with open("/etc/hosts", 'r') as hoststream:
            hosts = [host.replace(oldname, newname) for host in hoststream]
        with open("/etc/hosts", 'w') as hoststream:
            for host in hosts:
                hoststream.write(host)

def add_user(user, name, hostname):
    """Add the user (if not already present), with their password
    disabled but ssh login allowed.
    Also put them in /etc/sudoers, and add them to the GPIO group."""
    if user and user == "":
        logging.warn("No user specified to add_user")
        return None
    try:
        _ = pwd.getpwnam(user)
    except KeyError:
        sh('adduser --disabled-password --gecos "%s" %s' % (name, user))
        print("run 'sudo passwd %s' to set your password" % user)
        print("then on desktop, do this: ssh-copy-id %s@%s" % (user, hostname))

        sh("ssh-keygen -A && update-rc.d ssh enable && invoke-rc.d ssh start") # from the insides of raspi-config

    append_to_file_if_missing("/etc/sudoers",
                              user,
                              "%s    ALL=(ALL:ALL) ALL\n" % user)

    append_to_lines_starting("/etc/group",
                             "gpio",
                             "," + user)

    return user

###########
# Actions #
###########

def git_clone(repo, git_target_protocol='git'):
    """Clone a git repo, if we don't already have it.
    Since .ssh isn't yet set up, fetch with http and optionally patch it to look
    like .git afterwards."""
    directory = os.path.basename(repo)[:-4]
    if not os.path.isdir(directory):
        logging.info("cloning %s into %s", repo, directory)
        print("cloning %s into %s" % (repo, directory))
        original = repo
        if repo.startswith("git@github.com:"):
            repo = "https://github.com/" + repo[len("git@github.com:"):]
        print("cloning", repo)
        sh("git clone " + repo)
        if repo != original and git_target_protocol == 'git':
            replace_string_in_file(os.path.join(directory, ".git", "config"),
                                   "https://github.com/",
                                   "git@github.com:")

def sh(command):
    logging.debug("Running command %s", command)
    os.system(command)

##############
# Main logic #
##############

def assemble_configuration(args):
    """Assemble and return a configuration."""
    mac = uuid.getnode()        # not using getmac because it's not installed yet

    description = {
        'original-hostname': socket.gethostname(),
        'model': model(),
        'mac-addr': args.mac_addr or (':'.join(["%02x" % (mac >> x & 0xff) for x in range(0, 8*6, 8)][::-1])),
        'serial': file_contents("/proc/device-tree/serial-number")
        }

    if args.host_class:
        description['host-class'] = args.host_class

    confname = args.config
    if '%' in confname:
        confname %= description

    all_configuration = get_configuration(confname, {})
    if 'redirect' in all_configuration:
        all_configuration = get_configuration(all_configuration['redirect'] % description,
                                              {},
                                              all_configuration)

    host_descriptions = all_configuration.get('hosts', {})
    host_classes = all_configuration.get('host-classes', {})
    configuration = {}

    # Try various forms of host identity; possibly one of them will
    # yield a host-class, and may also give us a hostname:
    activate('global', host_classes, configuration, host_classes)
    activate(description['original-hostname'], host_descriptions, configuration, host_classes)
    activate(description['mac-addr'], host_descriptions, configuration, host_classes)
    activate(description['serial'], host_descriptions, configuration, host_classes)
    # There may be some information specific to an individual host,
    # but by name rather than MAC address or serial number:
    activate(configuration['hostname'], host_descriptions, configuration, host_classes)
    # If we're going to get a host class, we will have got it by now:
    activate(configuration.get('host-class'), host_classes, configuration, host_classes)
    activate(description.get('host-class'), host_classes, configuration, host_classes)

    # overrides from the command line:
    for k, v in vars(args).items():
        if v:
            configuration[k] = v

    return configuration

def remount(ext_disk, mount_point,
            home_directory, user):
    """Move a partition to a new mount point.
    Also, optionally make symlinks from the user's home directory to
    everything in a home-like directory in the partition, and optionally
    transfer ownership of the link targets to the user."""
    if ext_disk and os.path.exists(ext_disk) and mount_point:
        logging.info("Moving %s to mount point %s", ext_disk, mount_point)
        sh("umount " + ext_disk)
        append_to_file_if_missing("/etc/fstab",
                                  ext_disk,
                                  "%s %s ext4 defaults 0 0\n" % (ext_disk, mount_point))
        os.makedirs(mount_point, dirmask, True)
        sh("mount " + ext_disk)
        if home_directory and os.path.isdir(mount_point):
            user_dir = os.path.join(mount_point, "home", user)
            if os.path.isdir(user_dir):
                logging.info("Linking user files in %s from HDD", user_dir)
                for filename in glob.glob(user_dir+"/*"):
                    link = os.path.join(home_directory, os.path.basename(filename))
                    if not os.path.exists(link):
                        logging.info("  Linking %s to %s", link, filename)
                        os.symlink(filename, link)
                        if user:
                            sh("chown -R %s:%s %s" % (user, user, filename))
        else:
            logging.warn("No directory found at mount point %s", mount_point)
    else:
        logging.warn("External disk %s not found", ext_disk)

def get_user_projects(configuration, home_directory):
    """Get the user's collection of projects from a network repository.
This currently assumes github's repo listing API>"""
    # This should be relative to the user's home directory, or
    # absolute (avoiding any confusion about using $HOME coming from
    # this program running as root until it changes uid).
    projects_dir_name = configuration.get('projects-directory')
    if projects_dir_name:
        projects_dir = (projects_dir_name
                        if os.path.isabs(projects_dir_name)
                        else os.path.join(home_directory, projects_dir_name))
        os.makedirs(projects_dir, dirmask, True)
        os.chdir(projects_dir)
        logging.info("Cloning projects into %s", projects_dir)
        for repo in requests.get(configuration['github-list']).json():
            if os.path.isdir(os.path.join(projects_dir, repo['name'])):
                logging.info("Already got repo %s", repo['name'])
            else:
                git_clone(repo['git_url'], configuration['git-target-protocol'])

def get_repos(configuration, home_directory, repos):
    # This should be relative to the user's home directory, or
    # absolute (avoiding any confusing about using $HOME coming from
    # this program running as root until it changes uid).
    repos_dir_name = configuration.get('repos-directory')
    repos_directory = (repos_dir_name
                       if os.path.isabs(repos_dir_name)
                       else os.path.join(home_directory, repos_dir_name))

    if repos and repos_directory:
        repos_directory = os.path.expandvars(repos_directory)
        logging.info("Fetching %s into %s", repos, repos_directory)
        for repo in repos:
            site, author, reponame = git_site_author_and_repo(repo)
            author_directory = os.path.join(repos_directory, site, author)
            os.makedirs(author_directory, dirmask, True)
            repodir = os.path.join(author_directory, reponame)
            if os.path.isdir(repodir):
                logging.info("updating %s", repo)
                os.chdir(repodir)
                sh("git pull")
            else:
                logging.info("cloning %s under author directory %s", repo, author_directory)
                print("cloning %s under author directory %s" % (repo, author_directory))
                os.chdir(author_directory)
                git_clone(repo, configuration['git-target-protocol'])

def install_dotfiles(configuration, home_directory):
    """Copy the user's dotfiles into place."""
    repos_dir = configuration.get('repos-directory')
    dot_files = configuration.get('dot-files')
    config_project = configuration.get('config-repo')
    logging.info("dot_files are %s and config_project is %s in the repos_dir %s",
                 dot_files, config_project, repos_dir)
    if dot_files and config_project:
        config_dir = os.path.join(home_directory, repos_dir, config_project)
        logging.info("config dir is %s", config_dir)
        for dot_file in dot_files:
            origin = os.path.join(config_dir, dot_file)
            logging.debug("considering copying %s", origin)
            if os.path.isfile(origin):
                logging.debug("copying %s with a dot, into %s", origin, home_directory)
                shutil.copy(origin,
                            os.path.join(home_directory, "." + dot_file))

def apply_config(configuration):
    """Apply a configuration dictionary to the current host."""
    if configuration.get('hostname', "") != "":
        set_hostname(configuration['hostname'])

    hostname = socket.gethostname()
    hostaddr = socket.gethostbyname(hostname)

    logging.info("Running on host %s at address %s", hostname, hostaddr)

    if 'apt-remove' in configuration:
        logging.info("Uninstalling these packages using apt: %s", ", ".join(configuration['apt-remove']))
        for package in configuration['apt-remove']:
            sh("apt-get remove %s" % package)
    if 'pip-remove' in configuration:
        logging.info("Uninstalling these packages using pip: %s", ", ".join(configuration['pip-remove']))
        for package in configuration['pip-remove']:
            sh("pip3 uninstall %s" % package)
    if 'apt-install' in configuration:
        logging.info("Installing these packages using apt: %s", ", ".join(configuration['apt-install']))
        for package in configuration['apt-install']:
            sh("apt-get install --assume-yes %s" % package)
    if 'pip-install' in configuration:
        logging.info("Installing these packages using pip: %s", ", ".join(configuration['pip-install']))
        for package in configuration['pip-install']:
            sh("pip3 install %s" % package)

    user = add_user(configuration.get('user'),
                    configuration.get('name'),
                    hostname)
    home_directory = (pwd.getpwnam(user)[5]
                      if user
                      else os.path.join("/home", configuration.get('user')))

    if not configuration.get('no-partition-ops', False):
        for ext_disk, mount_description in configuration.get('mounts', {}).items():
            remount(ext_disk,
                    mount_description['mount-point'],
                    mount_description['link-to-home'] and home_directory,
                    mount_description['take-ownership'] and user)

    if configuration.get('suppress-auto-login', False):
        prepend_to_lines_starting("/etc/lightdm/lightdm.conf", "autologin-user", "# ")

    for system_directory in configuration.get('system-directories', []):
        os.makedirs(system_directory, dirmask, True)
    for root_action in configuration.get('root-actions', []):
        sh(root_action)

    # Do the rest as the new user
    if user:
        udata = pwd.getpwnam(user)
        uid = udata[2]
        gid = udata[3]
        logging.info("Doing rest of setup as user %s (uid %d, gid %d)", user, uid, gid)
        os.setgid(gid)          # can't do this after the setuid, because of not being root any longer
        os.setuid(uid)
        # os.seteuid(uid)
        # os.setegid(gid)
    else:
        logging.info("User not specified, so completing setup as root")

    get_user_projects(configuration, home_directory)
    get_repos(configuration, home_directory, configuration.get('git-repos'))
    install_dotfiles(configuration, home_directory)

    for user_directory in configuration.get('user-directories', []):
        logging.info("Creating user directory %s", user_directory)
        os.makedirs(os.path.join(home_directory, user_directory), dirmask, True)
    for user_action in configuration.get('user-actions', []):
        logging.info("Running user action %s", user_action)
        sh(user_action)

    if user:
        print("Now run 'passwd %s' as root and set your initial user password." % user)
        print("Then on your 'home' machine, you may want to do this: ssh-copy-id %s@%s" % (user, hostname))

################
# Main program #
################

def main():

    start_time = time.time()

    parser = argparse.ArgumentParser()
    parser.add_argument("--user",
                        help="""The account name of the user to create.""")
    parser.add_argument("--name",
                        help="""The full name of the user.""")
    parser.add_argument("--host",
                        help="""The name to give the host.""")
    parser.add_argument("--ext-drive",
                        help="""The expected name of an external drive.""")
    parser.add_argument("--mount-point",
                        help="""The mount point to place the external drive at,
                        if there is one.""")
    parser.add_argument("--config",
                        default="https://raw.githubusercontent.com/hillwithsmallfields/land/trunk/land.json",
                        help="""Filename or URL () overriding built-in settings.
                        Command line --user, --name, and --host override this file.
                        If the string has % in it, named %-substitution is done,
                        with a dictionary binding 'origin-hostname', 'model', 'mac-addr',
                        and 'serial'.""")
    parser.add_argument("--default-config",
                        action='store_true',
                        help="""Use a standard configuration file.""")
    parser.add_argument("--auto-config",
                        action='store_true',
                        help="""Use a standard configuration file which is different
                        for each model of Pi.""")
    parser.add_argument("--dry-run",
                        action='store_true',
                        help="""Assemble a configuration, but don't apply it.""")
    parser.add_argument("--mac-addr",
                        help="""Supply MAC address to select a configuration.
                        In conjunction with --dry-run, lets you check the configuration
                        from your development host without having to load it onto a target
                        host.""")
    parser.add_argument("--host-class",
                        help="""The kind of installation you want.""")
    parser.add_argument("--logfile",
                        default="landing.log")
    parser.add_argument("--loglevel",
                        help="""The loglevel to set.""")
    args = parser.parse_args()

    logger = logging.getLogger('lander')
    logging.basicConfig(filename=args.logfile)
    if args.loglevel:
        logger.setLevel(args.loglevel.upper())

    if getpass.getuser() != 'root' and not args.dry_run:
        print("This program must be run as root")
        sys.exit(1)

    config = assemble_configuration(args)

    if args.dry_run:
        print("Assembled configuration", json.dumps(config, indent=4))
    else:
        apply_config(config)

    logging.info("Setup took", time.time() - start_time, "seconds.")

if __name__ == "__main__":
    main()
